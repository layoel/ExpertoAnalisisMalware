# Experto en Ingeniería Inversa e Inteligencia Malware

## Análisis Estático Muestra Sample

Cuando llegamos a la fase de análisis de código debemos tener registrado:
Resultados del análisis de ficheros
• Cadenas relevantes
• Funciones relevantes que importa
• Localización del código, contenido secciones, overlay, etc.
Procesos que crea y/o modifica en el sistema
• Técnicas de inyección que aparentemente emplea
• Mecanismo empleado para lanzar procesos a ejecución
• Librerías detectadas en memoria
Conexiones de red que intenta establecer
• Nombres de dominios, puertos empleados y protocolos

Para este análisis vamos a usar IDA Pro

--------------------------SIN EJECUTAR------------------------------
Inicialmente vamos a ver las strings para ver si hay alguna interesante.

![imagen](*****************************str.JPG)

Vemos que como en el análisis estático aparece en varias ocasiones  adobe systems, lo que parece un correo de soporte de adobe, además de el nombre de las 3 funciones que nada mas abrir el fichero con IDA nos las nombra como closeHandle, variantInit y GetDC. También vemos el nombre de 3 librerías oleaut32.dll, user32.dll y kernel32.dll también si filtramos encontramos en 6 ocasiones la cadena MZ que podría indicar el inicio de ficheros embebidos con formato PE, pero también podria ser solo coincidencia o que estén ahi para despistar, hasta que no lo llevemos a ejecución no lo podremos confirmar.

![imagen](*****************************mz.JPG)

Si nos fijamos en las funciones que reconoce IDA, tenemos 4 funciones de usuario de las cuales una de ellas es la más usada por sample.bin y por lo que parece es para saber donde empieza el código de un fichero PE.

![imagen](*****************************func1.JPG)

HE DESACTIVADO EL ASLR EN EL EJECUTABLE CON PE BEAR PARA QUE SIEMPRE SE CARGUE EN LAS MISMAS DIRECCIONES DE MEMORIA. (lo hice tras varias ejecuciones por eso hay capturas con diferentes direcciones de memoria del principio del documento con respecto al final)

Mirando a simple vista el desensamblado nos llaman la atención unas cuantas funciones que son **call registro** es una forma que tienen los programadores de malware para ocultar las funciones así no funcionan las referencias cruzadas con ida cuando desensamblamos y no tenemos la información de esa función en cada sitio donde se llama.

***************************************ç
-- si encuentro un and esp, 0xFFFFFFFFF0h significa que alinea la pila a 16bits

-- dword-546231 es una variable global 

-- desactivar ASLR para que siempre se carguen en las mismas direcciones de memoria. ProcesExpl-caracteristicas-relocation information is stripped (marcarlo)
263

-- 
***************************************
--------------------------EN EJECUCION------------------------------
Nada más empezar localizamos un fichero PE:

Añadimos 3 estructuras nuevas para poder instanciarlas en memoria, image dos headers, *Image NT Headers* y image sections headers y las instanciamos en memoria.

Con el programa en ejecución, en el código vemos que a un registro (*eax*) le suma **3Ch** 

![imagen](*****************************IMPORT1.JPG)

si nos vamos a la vista general en el que vemos todas las instrucciones siguientes vemos que acontinuación de esa dirección aparecen los caracteres This program can not be run in DOS mode y si miramos justo en la direccion a la que hemos accedido menos 3C vemos el MZ que es el inicio de la cabecera del fichero PE 

![imagen](*****************************IMPORT2.JPG)

cargamos con Alt+Q el *Image Dos Headers*
![imagen](*****************************IMPORT3.JPG)

lo que vemos subrayado en amarillo es lo que tenemos que sumarle a la direccion base para poder llegar al inicio de *Image NT Headers* hacemos lo mismo que antes y vemos la estructura de *Image NT Headers*.

![imagen](*****************************IMPORT4.JPG)

Por último nos fijamos en el *Image NT Headers* el campo **numberofsections** y hacemos lo mismo para todas las secciones, en este caso este fichero tiene *4 secciones*, por lo que tenemos 4 veces la estructura *Image Section Headers*. (En la captura tiene otras direcciones de memoria que no corresponden con las anteriores porque son de otra ejecución).

![imagen](*****************************IMPORT5.JPG)

Tras ejecutar gran parte de la funcion **start** y renombrar algunas funciones y librerias de kernel32 y ntdll, cuando termina la función devuelve un EIP que no está dentro del código reconocido.

![imagen](*****************************codigoOculto.JPG)

Continuamos la ejecución y tras avanzar ocurre lo mismo que tras terminar la funcion start, aparece un puntero a un EIP que no teniamos localizado y van cargandose nuevas zonas. Encontramos otro fichero PE oculto en la memoria reservada para wow64cpu.dll lo he localizado porque despues de llevar un rato analizando linea a línea el código de sample.bin y tras hacer mas espacio en el heap o eso parecía con las funciones a las que llamaba, por lo que he vuelto a consultar las strings por si habia alguna nueva y he encontrado ***4 ficheros PE***.

![imagen](*****************************pe.JPG)

- En **Wow64cpu.dll** con la siguiente estructura:

*Image Dos Headers*:

![imagen](*****************************wowpe.JPG)

*Image NT Headers*:

![imagen](*****************************wowpe2.JPG)

*Image Section Headers*: segun el NT headers este fichero tiene 5 secciones que se pueden ver a continuacion en el código.

![imagen](*****************************wowpe3.JPG)

- Otro esta localizado en **cryptbase.dll**

*Image Dos Headers*:

![imagen](*****************************cryp1.JPG)

*Image NT Headers*:

![imagen](*****************************cryp2.JPG)

*Image NT Headers*: tiene 4 secciones que son .text .data .rsrc .reloc

![imagen](*****************************cryp2.JPG)

Otro PE está en **sspicli.dll**

![imagen](*****************************sspi.JPG)

tambien con 4 secciones: .text .data .rsrc .reloc


Dentro del codigo del malware, el generado a posteriori, he localizado algunas consultas sql que resultan sospechosas, parece que consultan los datos de las cookies y las credenciales de usuario, podría ser para robar credenciales.


![imagen](*****************************sql.JPG)

También encontramos claves de registro y algunos de los dominios que vimos en dinámico a los que intentaba conectarse.

![imagen](*****************************dom.JPG)

Una parte del código malicioso es la siguiente:

![imagen](*****************************mal.JPG)

Porque busca una función en una Dll, si es la funcion que buscaba cambia los punteros de esa función a la funcion con el mismo nombre pero modificada (hace hooking).


![imagen](*****************************mal2.JPG)

Si accedemos a cualquiera de esas funciones podemos resolver la IAT cambiando el tipo de dato.

![imagen](*****************************IAT.JPG)




call $+5
![imagen](*****************************eip+5.JPG) 
Manejador de excepciones para esconder una función
