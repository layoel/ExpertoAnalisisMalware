# Experto en Ingeniería Inversa e Inteligencia Malware

## Análisis Estático Muestra Sample

Cuando llegamos a la fase de análisis de código debemos tener registrado:
Resultados del análisis de ficheros
• Cadenas relevantes
• Funciones relevantes que importa
• Localización del código, contenido secciones, overlay, etc.
Procesos que crea y/o modifica en el sistema
• Técnicas de inyección que aparentemente emplea
• Mecanismo empleado para lanzar procesos a ejecución
• Librerías detectadas en memoria
Conexiones de red que intenta establecer
• Nombres de dominios, puertos empleados y protocolos.

Todo esto anterior lo tenemos registrado de los análisis estático y dinámico.

Para el análisis de código vamos a usar **IDA Pro**.

### Antes de ejecutar sample.bin

Inicialmente vamos a ver las **strings** para ver si hay alguna interesante.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/str.JPG)

Vemos que como en el análisis estático aparece en varias ocasiones *adobe systems*, lo que parece *un correo de soporte de adobe*, además de el nombre de las 3 funciones que nada mas abrir el fichero con IDA nos las nombra como *closeHandle*, *variantInit* y *GetDC*. También vemos el nombre de 3 librerías *oleaut32.dll*, *user32.dll* y *kernel32.dll* también si filtramos encontramos en 6 ocasiones la cadena MZ que podría indicar el inicio de ficheros embebidos con formato PE, pero también podria ser solo coincidencia o que estén ahi para despistar, hasta que no lo llevemos a ejecución no lo podremos confirmar. (Hasta aquí, nada nuevo)

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/mz.JPG)

Si nos fijamos en las funciones que reconoce IDA, tenemos 4 funciones de usuario de las cuales una de ellas es la más usada por sample.bin (lo comprobamos con las referencias cruzadas) y por lo que parece es para saber donde empieza el código de un fichero PE.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/func1.jpg)

El análisis lo hice tras varias ejecuciones por eso hay capturas con diferentes direcciones de memoria del principio del documento con respecto al final.

Mirando a simple vista el desensamblado nos llaman la atención unas cuantas funciones que son **call registro** es una forma que tienen los programadores de malware para ocultar las funciones así no funcionan las referencias cruzadas con ida cuando desensamblamos y no tenemos la información de esa función en cada sitio donde se llama.


### Debugueando sample.bin

Nada más empezar localizamos un fichero PE:

Añadimos 3 estructuras nuevas para poder instanciarlas en memoria, image dos headers, *Image NT Headers* y image sections headers y las instanciamos en memoria.

Con el programa en ejecución, en el código vemos que a un registro (*eax*) le suma **3Ch** 

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/IMPORT1.JPG)

si nos vamos a la vista general en el que vemos todas las instrucciones siguientes vemos que acontinuación de esa dirección aparecen los caracteres *This program can not be run in DOS mode* y si miramos justo en la direccion a la que hemos accedido menos 3C vemos el MZ que es el inicio de la cabecera del fichero PE 

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/IMPORT2.JPG)

cargamos con Alt+Q el *Image Dos Headers*
![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/IMPORT3.JPG)

lo que vemos subrayado en amarillo es lo que tenemos que sumarle a la direccion base para poder llegar al inicio de *Image NT Headers* hacemos lo mismo que antes y vemos la estructura de *Image NT Headers*.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/IMPORT4.JPG)

Por último nos fijamos en el *Image NT Headers* el campo **numberofsections** y hacemos lo mismo para todas las secciones, en este caso este fichero tiene *4 secciones*, por lo que tenemos 4 veces la estructura *Image Section Headers*. (En la captura tiene otras direcciones de memoria que no corresponden con las anteriores porque son de otra ejecución).

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/IMPORT5.JPG)

Tras ejecutar gran parte de la funcion **start** y renombrar algunas funciones y librerias de kernel32 y ntdll, cuando termina la función devuelve un EIP que no está dentro del código reconocido.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/codigoOculto.JPG)

Continuamos la ejecución y tras avanzar ocurre lo mismo que tras terminar la funcion start, aparece un puntero a un EIP que no teniamos localizado y van cargandose nuevas zonas. ¡Esta es la carga que ocultaba el malware! Encontramos otro fichero PE oculto en la memoria reservada para wow64cpu.dll lo he localizado porque despues de llevar un rato analizando linea a línea el código de sample.bin y tras hacer mas espacio en el heap o eso parecía con las funciones a las que llamaba, por lo que he vuelto a consultar las strings por si habia alguna nueva y he encontrado ***4 ficheros PE***.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/pe.JPG)

- En **Wow64cpu.dll** con la siguiente estructura:

*Image Dos Headers*:

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/wowpe.JPG)

*Image NT Headers*:

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/wowpe2.JPG)

*Image Section Headers*: segun el NT headers este fichero tiene 5 secciones que se pueden ver a continuacion en el código.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/wowpe3.JPG)

- Otro esta localizado en **cryptbase.dll**

*Image Dos Headers*:

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/cryp1.JPG)

*Image NT Headers*:

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/cryp2.JPG)

*Image NT Headers*: tiene 4 secciones que son .text .data .rsrc .reloc

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/cryp2.JPG)

Otro PE está en **sspicli.dll**

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/sspi.JPG)

tambien con 4 secciones: .text .data .rsrc .reloc


Dentro del codigo del malware, el generado a posteriori, he localizado algunas consultas sql que resultan sospechosas, parece que consultan los datos de las cookies y las credenciales de usuario, podría ser para robar credenciales.


![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/sql.JPG)

También encontramos claves de registro y algunos de los dominios que vimos en dinámico a los que intentaba conectarse.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/dom.JPG)

Una parte del código malicioso es la siguiente:

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/mal.JPG)

Porque busca una función en una Dll, si es la funcion que buscaba cambia los punteros de esa función a la funcion con el mismo nombre pero modificada.


![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/mal2.JPG)

Si accedemos a cualquiera de esas funciones podemos resolver la IAT cambiando el tipo de dato.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/iat.JPG)

localizo la función que hace la inyección de código en las dll, para ello usa las funciones de **buscarFunción** (yo la he renombrado así), usa también GetProcAddress coge la dll PAVSHOOK.dll y con GetModuleHandle cambia el código, si ha terminado la modificación, libera la librería y sale de la función InyectarCódigo, sino vuelve a GetProcAddress y sigue en el bucle.



En imágenes se realiza lo siguiente: (marcado en amarillo el camino para realizar la inyección).

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/in1.JPG)
![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/in2.JPG)
![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/in3.JPG)

Aqui vemos completa la función InyectarCodigo

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/estr.JPG)

En memoria está en:
![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/mem.JPG)


Una de las tecnicas encontradas en el malware para alterar el flujo de la ejecución normal es la llamada **call $+5**

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/eip+5.JPG) 

Además de los call a registro que encontramos en muchas partes del código que hacen que no funcionen las referencias cruzadas, por lo que no sabemos  cuantas veces se usa esa función.

Hasta donde he llegado analizando podemos ver un gráfico con la información descubierta y compararla con la inicial que proveía el fichero sample.bin y ver que ocultaba mucha información que ha ido cargando en memoria a posteriori.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/grf.JPG)

Hasta aquí dejo el [análisis](![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/ida) con el [volcado de memoria](![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/mem).

Tras las capturas anteriores seguí renombrando funciones y descubriendo nuevos trozos de código pero por una excepción que me dió, finalizó el programa y no tengo la captura de memoria, pero sí la bd de [ida pro](![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/ida2) y el gráfico de lo descubierto hasta ese momento.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisCodigo/imagenes/grf2.JPG)