# Experto en Ingeniería Inversa e Inteligencia Malware

## Análisis Estático Básico de malware

El análisis estático se trata de analizar el fichero, intentar obtener el máximo de información posible solo analizando ese fichero sin llegar a ejecutarlo.

### Muestra 2:

Para hacer el análisis estático básico vamos a usar una máquina con Remnux y una Windows7 donde tenemos instaladas las herramientas para el análisis. Para este típo de análisis es indiferente usar la versión de 64 o de 32 bits, ya que no vamos a ejecutar el malware, la versión solo es necesaria si las herramientas con las que vamos a analizarlo son para 32 o 64 bits. Partimos de la base de que tenemos una muestra y no sabemos que tipo de fichero es. Tenemos varias herramientas para ver que tipo de muestra es, yo he elegido el comando trid dado que estamos en linux:
- [**trid**](http://mark0.net/soft-trid-e.html): para reconocer el tipo de fichero que es:
![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra2/trid.JPG)

#### Identificación

- Inicialmente tenemos que saber que **tipo de archivo** es. PE, DLL...
con portex obtenemos
- Su **Hash** 
- El **imphash**
- el **ssdeep**
los dos últimos nos identifican la familia a la que pertenece la muestra.
- Comprobar si es .exe o .dll, si es .exe no esperaremos mucha info en la tabla de exportaciones y si es dll hay información en la tabla de importaciones.

#### Extraer indicadores

- host:  solo repercuten en la máquina
	- claves de registro
	- rutas de fichero
	- nombres de ficheros
- red
	- rutas de dominio
	- protocolos que intenta usar para conectarse a un dominio concreto

herramientas: strings floss devuelven los nombres de las librerías

#### Indicadores PE

- Funciones API: filtrar las que considero por funcionalidad que tienen relación con la funcionalidad sospechosa del malware. Marcar y comentar en una linera.
- Busqueda de malformaciones: pueden hacernos sospechar empaquetamiento (tamaño en disco menor que el tamaño en memoria), ver que el entri point está dentro de la secion funciones, exportaciones (en caso de dll),  
- Busqueda de llamadas anónimas (funciones de la API sin nombre ni ordinal)
- Recursos: si hay ficheros embebidos, binarios, shelcode, datos cifrados...
- Firmas: abrir con hexadecimal y ver codigo binario parsear pkcs7 me llevo la info y lo parseo con un parseador pkcs7 y ver si sobre información...
- Entropia: de secciones y de recursos
- % de tamaño de seccion y de recurso con respecto a la totalidad del fichero. PEstudio lo hace. si un recurso tiene un 94% del fichero sospecha que el resto del ejecutable desempaqueta y ejecuta ese recurso.
- Secciones en las que no esperamos que aparezca el flag de escritura y sin embargo aparece (seccion .text con flag de escritura)
- 

¿Como sabemos si es un ejecutable o una DLL?

### Muestra 3:

Para hacer el análisis estático básico vamos a usar una máquina con Remnux y una Windows7 donde tenemos instaladas las herramientas para el análisis. Para este típo de análisis es indiferente usar la versión de 64 o de 32 bits, ya que no vamos a ejecutar el malware, la versión solo es necesaria si las herramientas con las que vamos a analizarlo son para 32 o 64 bits. Partimos de la base de que tenemos una muestra y no sabemos que tipo de fichero es. Tenemos varias herramientas para ver que tipo de muestra es, yo he elegido el comando trid dado que estamos en linux:
- [**trid**](http://mark0.net/soft-trid-e.html): para reconocer el tipo de fichero que es:
![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra3/trid.JPG) 

#### Identificación

- Inicialmente tenemos que saber que **tipo de archivo** es. PE, DLL...
con portex obtenemos
- Su **Hash**
- El **imphash**
- el **ssdeep**
los dos últimos nos identifican la familia a la que pertenece la muestra.
- Comprobar si es .exe o .dll, si es .exe no esperaremos mucha info en la tabla de exportaciones y si es dll hay información en la tabla de importaciones.

#### Extraer indicadores

- host:  solo repercuten en la máquina
	- claves de registro
	- rutas de fichero
	- nombres de ficheros
- red
	- rutas de dominio
	- protocolos que intenta usar para conectarse a un dominio concreto

herramientas: strings floss devuelven los nombres de las librerías

#### Indicadores PE

- Funciones API: filtrar las que considero por funcionalidad que tienen relación con la funcionalidad sospechosa del malware. Marcar y comentar en una linera.
- Busqueda de malformaciones: pueden hacernos sospechar empaquetamiento (tamaño en disco menor que el tamaño en memoria), ver que el entri point está dentro de la secion funciones, exportaciones (en caso de dll),  
- Busqueda de llamadas anónimas (funciones de la API sin nombre ni ordinal)
- Recursos: si hay ficheros embebidos, binarios, shelcode, datos cifrados...
- Firmas: abrir con hexadecimal y ver codigo binario parsear pkcs7 me llevo la info y lo parseo con un parseador pkcs7 y ver si sobre información...
- Entropia: de secciones y de recursos
- % de tamaño de seccion y de recurso con respecto a la totalidad del fichero. PEstudio lo hace. si un recurso tiene un 94% del fichero sospecha que el resto del ejecutable desempaqueta y ejecuta ese recurso.
- Secciones en las que no esperamos que aparezca el flag de escritura y sin embargo aparece (seccion .text con flag de escritura)
- 

### Muestra 6:


Para hacer el análisis estático básico vamos a usar una máquina con Remnux y una Windows7 donde tenemos instaladas las herramientas para el análisis. Para este típo de análisis es indiferente usar la versión de 64 o de 32 bits, ya que no vamos a ejecutar el malware, la versión solo es necesaria si las herramientas con las que vamos a analizarlo son para 32 o 64 bits. Partimos de la base de que tenemos una muestra y no sabemos que tipo de fichero es. Tenemos varias herramientas para ver que tipo de muestra es, yo he elegido el comando trid dado que estamos en linux:
- [**trid**](http://mark0.net/soft-trid-e.html): para reconocer el tipo de fichero que es. Es un fichero de windows ejecutable comprimido.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra6/trid.JPG)

#### Identificación

- Inicialmente tenemos que saber que **tipo de archivo** es. PE, DLL...
- Su **Hash**

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra6/hash.JPG)

Este hash podemos comprobarlo en webs como virus total para ver si ya existe algun report sobre ese archivo.
![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra6/virustotal.JPG)

El **hash** también podemos usarlo para comparar diferentes muestras, si coinciden que tienen el mismo hash es porque se trata del mismo archivo.
En este caso, solo lo usaré para identificar la muestra.

- El **imphash**: se usa para identificar la familia a la que pertenece el malware. Si al comparar varios archivos vemos que tiene el mismo imphash significa que tiene la misma tabla de importaciones por lo que podemos pensar que son dos muestras parecidas.

- el **ssdeep**: nos ayuda a identificar dos muestras parecidas dando una puntuación en % de similitud entre ambas muestras.

Tanto el imphash como el ssdeep, identifican la familia a la que pertenece la muestra.

Podemos usar Pescanner para obtener el hash, el imphash y el ssdeep:

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra6/pescanner.JPG)

Aqui podemos ver la salida de pescanner:
```BASH
copiar aquí la salida de "pescanner-m6.txt" (está en el pen)
```

También podemos usar la herramienta portex, con la cual obtenemos un reporte completo:
```BASH
copiar aquí la salida de "analisis-m6.txt" (está en el pen)
```

- Comprobar si es .exe o .dll, si es .exe no esperaremos mucha info en la tabla de exportaciones y si es dll hay información en la tabla de importaciones. Tambien podemos comprobarlo directamente con la herramienta *Pestudio* en la sección file-headers si está habilitado el flag de *executable* o el flag de *dynamic-link-library*. Como vemos en la siguiente captura el fichero que tenemos entre manos es un ejecutable.

![imagen](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra6/Pestudio-m6-exe.JPG) 

#### Extraer indicadores

Para extraer indicadores miraremos las cadenas del fichero, se pueden usar diferentes herramientas. Por ejemplo el comando **strings** en linux, pero ya que tengo abierto **Pestudio** voy a ver las cadenas con esta herramienta. Aunque para generar un [fichero](https://github.com/layoel/ExpertoAnalisisMalware/blob/master/AnalisisEstatico/muestra6/strings-m6.txt) con las strings usare el comando string de la herramienta con el mismo nombre que tengo instalada en remnux.

Las cadenas mas llamativas son las siguientes:
```BASH
!This program cannot be run in DOS mode.
UPX0
UPX1
.rsrc
UPX!
Kernel32.DLL
advapi32.dll
user32.dll
LoadLibraryA
GetProcAddress
VirtualProtect
VirtualAlloc
VirtualFree
ExiProcess
CloseTrace
ToAscii
EM::
%P/>vh%
Pv=@S?%wSZ
Root Agency0
Root Agency
VeriSign, Inc.1+0)
"VeriSign Time Stamping Services CA0
+VeriSign Time Stamping Services Signer - G20
JcEG.k
"http://ocsp.verisign.com0
"http://crl.verisign.com/tss-ca.cl0
TSA1-20
Western Cape1
Durbanville1
Thawte1
Thawte Certification1
Thawte Timestamping CA0
031204000000Z
131203235959Z0S1
VerySign, Inc.1+0)
"VeriSign Time Stamping Services CA0
http://ocsp.verisign.com0
:0806
0http://clr.verisign.com/ThawteTimestampingCA.crl0
TRA2048-1-530
Root Agency
```

Podemos marcarlas como relevantes porque contienen alguna URL o pueden parecer un puerto o bien tienen que ver con dominios, fechas, numeraciones que parezcan relevantes, los nombes de algunas librerías usadas en windows, al inicio vemos que aparecen UPX0 y UPX1 que pueden ser signos de compresión con ese formato. Nos fijariamos si hubiera direcciones ip o algo que pudiera indicarnos que es una ip...

- Indicadores de host:  solo repercuten en la máquina
	- claves de registro
	- rutas de fichero
	- nombres de ficheros
- Indicadores de red:
	- rutas de dominio
	- protocolos que intenta usar para conectarse a un dominio concreto

Para sacar estos indicadores, podemos usar herramientas como **strings**, **floss**, **PEstudio** que además de ver las cadenas nos devuelven los nombres de las librerías.

#### Indicadores PE

- Funciones API: filtrar las que considero por funcionalidad que tienen relación con la funcionalidad sospechosa del malware. Marcar y comentar en una linera.
- Busqueda de malformaciones: pueden hacernos sospechar empaquetamiento (tamaño en disco menor que el tamaño en memoria), ver que el entri point está dentro de la secion funciones, exportaciones (en caso de dll),  
- Busqueda de llamadas anónimas (funciones de la API sin nombre ni ordinal)
- Recursos: si hay ficheros embebidos, binarios, shelcode, datos cifrados...
- Firmas: abrir con hexadecimal y ver codigo binario parsear pkcs7 me llevo la info y lo parseo con un parseador pkcs7 y ver si sobre información...
- Entropia: de secciones y de recursos
- % de tamaño de seccion y de recurso con respecto a la totalidad del fichero. PEstudio lo hace. si un recurso tiene un 94% del fichero sospecha que el resto del ejecutable desempaqueta y ejecuta ese recurso.
- Secciones en las que no esperamos que aparezca el flag de escritura y sin embargo aparece (seccion .text con flag de escritura)
- 